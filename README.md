# netSecFinalProject

1. Purpose
Secure IM client-server architecture with peer to peer communications.

1.1 High level entities: 
 
Our design has 3 entities: Server, Client, and User.
User: Human that interacts with the system. The user only remembers one password and should be confident in the security and authenticity of all messages on the system. The user sends messages to other users through the client.
Client: Connects on a peer to peer  basis with other clients to send messages. Receives peer keys from server. Maintains list of other users on network until given update by server.
Server: Authenticates users during login. Creates secret keys for peer to peer communication. Sends peer to peer secret keys to relevant clients. Maintains address book of clients. Checks that clients still exist on network. Updates clients when new client is added to network.

2. Assumptions
Server stores: Usernames, Hashed passwords, Client master Keys based on hashed passwords, Random number acting as Server master key, Client Session keys

SERVER DATABASE
Usernames
Hashed Passwords of Clients
Client master keys
IP addresses of Clients (Name-Ip address book)
Client session keys
Master Key of server
Session Key for Client-Client Communication

The following information is stored at Client side

CLIENT DATABASE
Client Session key (randomly generated)
Client-Client session key
Master Key (generated from password)

Key Generation :
The session key is a random number that we would be generated at every login
The master key is a hash of password and salt, which again would be randomized at every login

3. USE CASES
3.1 LOGIN
Description
User logs in with username and password
Actors
Server and client
Assumption
Server has an existing record about client and it’s hashed password
Steps
Client sends a login request
Server responds back with session key and Ticket granting ticket

3.2 LIST

Description
List of users online 
Actors
Server and Client
Assumption
Server maintains a list of online user by timely pinging them is-alive? Message and that list is automatically updated when a user logs in or logs out
Steps
Client sends a LIST REQUEST
Server replies back with name-ip address book of online clients

3.3 LOGOUT

Description
Client wishes to logout
Actors 
Client and server
Steps
Client sends a logout message
Server deletes the entry of client from name-ip address book of online users

3.3 PEER-PEER AUTHENTICATION

Description
To authenticate two clients who wish to interact
Actors
Client1 , Client 2 and server
Assumption
Server has already authenticated Client2. And it is online
Steps
Client1 requests server to provide a ticket to client2 for communication with other client
Server provides the ticket
Client1 sends the ticket to client2
Client2 authenticates and sends a message to server so as to acknowledge that it has received the ticket


3.4 PEER-PEER COMMUNICATION

Description
To communicate two clients
Actors
Client1 and Client2
Assumption
Both clients are online and have authenticated themselves
Steps
Client1 and Client2 do a diffie hellman exchange to generate a key
The key generated by diffie hellman is a secret and is used by AES as its key
The message is transferred with AES scheme with GCM mode

4. Protocols

4.1 User Server Authentication and Session establishment
4.1.1.Login
When a client logs in, the workstation on Alice’s behalf asks KDC Server for a session key. The server authenticates that request by 2 things :
If the entry of user is among registered users
If the master key matches that of user mentioned
The server generates a random puzzle, and sends the puzzle to the client. The server generates the puzzle in a way that it can predict reasonably well how much effort will be required to solve the puzzle (e.g., 100ms of computation). The client solves the puzzle, and then sends the solution encrypted with Alice’s master key
The KDC generates a session key Sc and transmits Sc encrypted with Client’s master key (Which is generated from Client’s password) to the client’s workstation. KDC also sends a ticket-granting-ticket (TGT) which is Sc, Client’s name and TGT’s expiration time encrypted with KDC’s master key. Also as a user logs in, the server updates the name-address book

The workstation makes use of Client’s master key (derived from password) to decrypt the encrypted Sc. After which workstation forgets Client’s password and only remembers Sc and TGT. So when client needs to talk to another client, it’s workstation transmits the TGT to KDC server along with name of client to which it needs a ticket. KDC decrypts the TGT to discover Sc and uses Sc to encrypt Client1-Client2 session key for Client1.  


Request
Flow
Details
Encryption Type
LOGIN 
Alice→ Server
ALICE || LOGIN
Plaintext
LOGIN
Server→ Alice
Puzzle


LOGIN
Alice→ Server 
{Response-to-puzzle || Na}amk
AES with GCM
LOGIN
Server→ Alice 
{Sa || TGT ||  Na+1}amk
AES with GCM

Na : Nonces generated by Alice to avoid replay attack
TGT = {ALICE || Sa || Time-expiry}server master key




4.1.2 Logout
When Client logs off, it sends
Client → Server : {LOGOUT || TGT}Kas
Server deletes the entry of client in Name-IP address book.

REQUEST
FLOW
DETAILS
Encryption Type
LOGOUT 
Alice→ Server
{LOGOUT || TGT || Na}Sa
AES with GCM mode
LOGOUT 
Server → Alice
{ACK || Na+1}Sa
AES with GCM mode

4.1.3 List

REQUEST
FLOW
DETAILS
ENCRYPTION TYPE
LIST
Alice→ Server
{LIST || TGT || Na}Sa
AES with GCM mode
LIST
Server-->Alice
{Name-Ip address book || Na+1}Sa
AES with GCM mode 

Na : Nonces generated by Alice
Maintaining Address Book at Client and Server side
Server periodically pings clients to find out who is alive
If no ack received delete entry in address book.
If there are any changes to address book send encrypted update to all clients


4.2 Peer to Peer Authentication
Here Alice informs KDC that it wants to talk to Bob, the KDC invents a session key Kab for Alice and Bob to share.
KDC  encrypts Kab with Bob’s master key for Bob (ticket to Bob)  and sends this encrypted Kab with Kab for Alice, all encrypted with session key of Alice. Here Alice can’t read what’s inside the ticket because it’s encrypted with Bob’s master key. Also the server deletes Kab or forgets Kab from its record. Thus even if server gets hacked, it cannot intercept through the communication.
So bob can decrypt the ticket and discover Kab and Alice’s name. Bob knows whoever knows Kab is acting on Alice’s behalf. Thus Alice and bob authenticate each other.
After authentication, Alice Bob creates their own Diffie Hellman Key and communicate with the new key generated.

Thus even if our KDC gets crashed or impersonated by attacker, it would not be able to intercept through the message exchange.

Request
Flow
Details
Encryption Type
P2P AUTH
Alice -->Server
{BOB || TGT(alice) || Na}Sa
AES with GCM
P2P AUTH
Server → Alice 
{Kab || {Kab || Ns || TGT(bob)}bmk || Na+1 }Sa
AES with GCM
P2P AUTH
Alice → Bob
{Kab || Ns ||TGT(bob)}bmk
AES with GCM
P2P AUTH
Bob→ Alice
{Na+1}Kab
AES with GCM
P2P AUTH
Bob→ Server
{Ns+1 || TGT(bob) || Nb}Sb
AES with GCM
P2P AUTH
Server→ Bob
{Nb+1}Sb
AES with GCM

Na : Nonce generated by Alice
Nb : Nonce generated by Bob
Ns : Nonce generated by Server
Sb : Session key Bob
4.3 Peer to Peer Communication



REQUEST
FLOW
DETAILS
ENCRYPTION TYPE
P2P Communication
Alice→ Bob
{g^a mod p || Na}Kab
AES with GCM
P2P Communication
Bob→ Alice
{g^b mod p || Na+1 || Nb}Kab
AES with GCM
P2P Communication
Alice→ Bob 
{M || Nb+1}Kaes 
AES with GCM

Na : Nonce generated by Alice
Nb : Nonce generated by Bob
 

5. Benefits
	
5.1 AUTHENTICATION
The design proposed above authenticates client-server communication with the help of Session keys and ticket granting ticket (TGT). While client-client communication is authenticated with ticket-to-client provided by the server
5.2 CONFIDENTIALITY
All message transfer is encrypted with AES and gcm mode with the session and private keys as described above. Also users are authenticated first before any message transfer.
5.3 DOS RESISTANCE
The design has resistance from Denial of Service attack because each time a client needs to talk to KDC Server. It shall be authenticated using TGT, session key or a master key depending on type of interaction.
5.4 PERFECT FORWARD SECRECY
In Client-server communication, we are providing Perfect forward secrecy by session keys which are randomly generated at each session. So no data is recorded for previous session.
In Client-Client communication, the client is authenticated with the ticket to client provided by the server, which has the session key for communication which is again changed at every session. After which the client produces a diffie hellman key and uses that key as a key for AES communication with GCM mode. And use this key for message communication. Server has no idea about this communication as it doesn’t have this key.
 5.5 DATA INTEGRITY
All the message communication is encrypted with the session keys using AES with GCM mode. Thus it guarantees that message is received as sent.
5.6 HANDLING DISTRUST OF THE SERVER
As explained above, the message communication between the client takes place with the new key generated by the clients, and server cannot possibly get that key. So even if server is compromised, the client-client communication is safe
5.7 PROTECTION FROM REPLAY ATTACKS
The communication above include nonces which protects it from replay attacks
5.8 PASSWORD PROTECTION
We have attempted to eliminate any transmission of password, encrypted or otherwise. Also the server stored the HMAC of the password. So apart from user nobody knows the password

6. Risks
6.1 Server Overrun
	In the case of a server overrun, all master keys are compromised. While the server will not be able to read any recorded conversations, all future authentication will be compromised.

6.2 User Trusting the application

The user only trusts the workstation to log in, after that the workstation is treated as untrustworthy and given as little information as possible.
